#+OPTIONS: num:nil toc:nil date:nil
#+LATEX_HEADER: \usepackage[cm]{fullpage}
# #+PROPERTY: header-args: :noweb yes :exports results

* tasks
** TODO change lilypond generation to actual lilypond output
** TODO check for extra commas (e.g. double septimal)
* microtonal lilypond example
#+begin_src lilypond :file micro.png
  \version "2.24.1"
  #(ly:set-option 'use-paper-size-for-page #f)
  #(ly:set-option 'tall-page-formats 'png)
  \paper{
    indent=0\mm
    tagline=""
    line-width=170\mm
    oddFooterMarkup=##f
    oddHeaderMarkup=##f
    bookTitleMarkup=##f
    scoreTitleMarkup=##f
  }
  \include "ekme-heji.ily"

  musico = {
    \accidentalStyle "dodecaphonic"
    c'4    % 1/1
    g'4    % 3/2
    esoaa' % 5/4
    bfoba' % 7/4
    foca'  % 11/8
    aoda'  % 13/8
    csoea'  % 17/16
    s2
  }

  musicu = {
    \accidentalStyle "dodecaphonic"
    c'4    % 1/1
    g'4    % 3/2
    esuaa' % 5/4
    bfuba' % 7/4
    fuca'  % 11/8
    auda'  % 13/8
    csuea'  % 17/16
  }
  \score {
    \new Staff
      {
        \new Voice
        {
          \musico \musico
        }
      }

  }  
#+end_src

#+RESULTS:
[[file:micro.png]]

* algorithm for factorization (pseudo)
[[https://people.revoledu.com/kardi/tutorial/BasicMath/Prime/Algorithm-PrimeFactor.html][Collected from here]]
#+DOWNLOADED: screenshot @ 2023-07-26 18:44:09
"#+attr_html: :width 300px :align left"
"#+attr_org: :width 1200px"
#+attr_html: :width 500px
[[file:img/algorithm_for_factorization_(pseudo)/2023-07-26_18-44-09_screenshot.png]]

* lua implementation
See also the original in [[file:~/org/babel/luastuff.org::*lua][lua]] (where there are more functions). Factorizes a number and returns its largest prime factor following this suggestion: [[*algorithm for factorization (pseudo)][algorithm for factorization (pseudo)]]

This version returns 1 in some instances (such as ~factorize(81)~ for example). The version below corrects this in an unusually clumsy way.
#+name: factorize
#+begin_src lua :results output :exports both
  function factorize(N)
     local p = 2
     while N >= p*p do
        while N % p == 0 do
           N = N / p end
        p = p+1
     end
        return N
  end

  io.write(factorize(80))
#+end_src

#+RESULTS: factorize
: 5

Corrects the erroneous return of 1 in some instances.
#+begin_src lua :results output :exports both
  function factorize(N)
     local p = 2
     local parr = {}
     while N >= p*p do
        while N % p == 0 do
           table.insert(parr, p)
           N = N / p end
        p = p+1
     end
     table.insert(parr, N)
     return parr
  end

  local a = factorize(81)
  print(math.max(table.unpack(a)))

#+end_src

#+RESULTS:
: 3

This pretty prints the output.
#+begin_src lua :results output :exports both
    function factorize(N)
       local p = 2
       io.write(N .. " = ")
       while N >= p*p do
          while N % p == 0 do
             io.write(p .. " * ")
             N = N / p end
          p = p+1
       end
          io.write(N .. "\n")
    end

  factorize(80)
#+end_src

#+RESULTS:
: 80 = 2 * 2 * 2 * 2 * 5.0

Check the largest prime number as factors for both numerator and denominator
#+begin_src lua :results output :exports both :noweb yes
  <<factorize>>
  function check_fraction(n, d)
     io.write(factorize(n))
     io.write(factorize(d))
  end

  check_fraction(81 80)

     -- io.write(factorize(81))
#+end_src

#+RESULTS:

* scheme implementation
:PROPERTIES:
:header-args: :results value :noweb yes
:END:
Introduction to using these scripts
- Set guile to be the active implementation
#+begin_src emacs-lisp
  (setf geiser-active-implementations '(guile))
#+end_src

#+RESULTS:
| guile |

** harmonic distance and similar
See [cite:@Nicholson2019] for an introduction and [[file:~/Dropbox/roam/references/Nicholson2019.org][the notes]] for more information. Also [cite:@Tenney2014]
and the [[file:/Volumes/Freedom/Dropbox/roam/references/Tenney2014.org::\[cite:@Tenney2014\]][notes to that paper]].
*** cents from ratio
Argument given as a string ratio.
#+name: cent_func
#+begin_src scheme :var ratio="5/4"
<<log2_func>>
(* 1200 (log2 (string->number ratio)))
#+end_src

#+RESULTS: cent_func
: 386.3137138648348

Same as above, but argument given as n, d (n/d)
#+begin_src scheme :var n=3 d=2 :results value
  <<log2_func>>
  (* 1200 (log2 (rationalize (inexact->exact (/ n d)) 1/100)))
#+end_src

#+RESULTS:
: 701.9550008653874
*** notation, ratio -> lilypond
Table of note names associated with indexes (cents/100) departing from the note C. Transposition is simple by adding number of half tone steps to the index lookup.
#+name: note_names
| ndx | name |
|-----+------|
|   0 | c    |
|   1 | cs   |
|   2 | d    |
|   3 | ds   |
|   4 | e    |
|   5 | f    |
|   6 | fs   |
|   7 | g    |
|   8 | gs   |
|   9 | a    |
|  10 | as   |
|  11 | b    |
|-----+------|

This function takes a ratio and maps it to the table ~note_names~ and returns the closest approximated scale tone from C.
- R is the ratio with which the function is called (n/d)
- c is the cent representation of the ratio where 1/1 is 0
- n is the calculated index based on cent value (+ 50) truncated to an integer
#+name: note_name_orig
#+begin_src scheme :var tbl=note_names :results value
  <<log2_func>>
  <<octave_reduction>>
  (define (note-name n d)
    (let* ((R (rationalize (inexact->exact (/ n d)) 1/100))
           (c (* 1200 (log2 R)))
           (n (inexact->exact (truncate (/ (+ c 50) 100)))))
      (car (cdr (assoc n tbl)))))

  (note-name 3 4)
#+end_src

#+RESULTS: note_name_orig
: as

This function takes a ratio R and maps it to the table ~note_names~ and returns a pair with the closest approximated scale tone from C and the octave.
- R is the ratio with which the function is called
- O (#t/#f) is if the note should be octave reduced or not
- transpose is the number of notes to transpose from standard (C)
  - c is the cent representation of the ratio where 1/1 is 0
  - n is the calculated index based on cent value (+ 50) truncated to an integer
  - oct is the octave position, 0 if octave-reduction is #t
#+name: note_name
#+begin_src scheme :var notes=note_names :results output :tangle test.scm
  <<log2_func>>
  <<octave_reduction>>
  (define (note-name R O transpose)
    (let* ((oct (if (eq? #t O)
                    0
                    (cdr (octave-reduction R))))
           (r (car (octave-reduction R)))
           (c (* 1200 (log2 r)))
           (n (remainder (inexact->exact
               (truncate (/ (+ (abs c) 50) 100))) 12)))
      (cons (car (cdr (assoc (+ n transpose) notes))) oct)))

;;  (display (note-name 1/4 #f 0))
#+end_src

#+RESULTS: note_name
: (c . 0)

Test function generating just the number (no table lookup)
#+name: note_number
#+begin_src scheme :results output :var notes=note_names
    <<log2_func>>
    <<octave_reduction>>
    (define (note-name R O)
      (let* ((r (octave-reduction R 0))
             (c (* 1200 (log2 (car r))))
             (n (remainder
                 (inexact->exact
                 (truncate (/ (+ (abs c) 50) 100))) 12)))
        ;;     (cons n (cdr r))))
        (abs n)))

     (display (note-name 2/3 #f))
#+end_src

#+RESULTS: note_number
: 7

Take a note number and the octave and returns the lilypond notation for octaves.
- note: the note numer 0 <= note < 12
- oct: the octave -6 < oct < 6
#+name: octave_to_lily
#+begin_src scheme
   (define (octave-notation oct)
     (if (and (> oct 0) (< oct 6))
         (octaves oct "")
         (if (and (< oct 0) (> oct -6))
             (sub-octaves oct ""))))
	   

   (define (octaves oct s)
     (if (<= oct 0)
         s
         (octaves (- oct 1) (string-append s "'"))))

   (define (sub-octaves oct s)
     (if (>= oct 0)
         s
         (sub-octaves (+ oct 1) (string-append s ","))))

;;  (octave-notation -3)
#+end_src

#+RESULTS: octave_to_lily
: ,,,

#+begin_src scheme :noweb yes :results output
    <<note_number>>
  (display (
note-name 2/1 #t))
#+end_src

#+RESULTS:
: (0 . 1)

Not working
#+begin_src scheme
  (define (test x s)
    (if (eq? x 0)
        s
        (if (and (> x 0) (< x 6))
            (begin (display x) (test (- 1 x) (string-append s "'")))
            (if (and (> x -6) (< x 0))
                (test (+ -1 x) (string-append s ","))))))
#+end_src
*** ocatve reduction
Multiply ratio by 1/2 as in the following:
#+name: simple_octave_reduction
#+begin_src scheme 
  (* 6/4 1/2)
#+end_src

#+name: octave_reduction_orig
#+begin_src scheme :results value
    (define (octave-reduction R)
      (if (>= R 2)
          (octave-reduction (* R 1/2))
          R))

  ;;  (octave-reduction 7/1)
#+end_src


This function takes any fraction as input and returns its octave normalized version. It returns a 'cons with the ratio and the octave.
- R ration to normalize
- n the index for the octave (always zero in the call)
#+name: octave_reduction
#+begin_src scheme :results output
  (define (octave-red R n)
        (if (>= R 2)
          (let ((i (+ n 1)))
            (octave-red (* R 1/2) i))
          (cons R n)))

  (define (octave-red-sub R n)
    (if (< R 1)
      (let ((i (- n 1)))
        (octave-red-sub (* R 2/1) i))
      (cons R n)))

  (define (octave-reduction R)
    (if (>= R 2)
        (octave-red R 0)
        (octave-red-sub R 0)
        )
    )

  (display (octave-reduction 2/1))
#+end_src

#+RESULTS: octave_reduction
: (1 . 1)

*** pitch distance
$f_a$ should be less than $f_b$
#+begin_src scheme :noweb yes :var fa=440 fb=880
  <<log2_func>>
  (- (log2 fa) (log2 fb))
#+end_src

#+RESULTS:
: -1.0

*** harmonic distance
#+begin_src scheme :noweb yes :var fa=440 fb=880
  <<log2_func>>
  (+ (log2 fa) (log2 fb))
#+end_src

#+RESULTS:
: 18.56271942704932

*** crystal growth
See page 48 of [cite:@Tenney2008]:

$S(y) = log_2(2*3^2) = 4.17$

#+begin_src scheme :noweb yes
  <<log2_func>>
  (log2 (* 2 (expt 3 2)))
#+end_src

#+RESULTS:
: 4.169925001442312

*** ratio difference
This is simple in scheme
#+begin_src scheme
  (/ 3/2 4/3)
#+end_src

and is the equivalence of multiplying $3/2 * 3/4$ (the reciprocal of the second fraction)
#+begin_src scheme
  (* 3/2 3/4)
#+end_src

#+RESULTS:
: 9/8

*** utility functions
#+name: log2_func
#+begin_src scheme
      (define (log2 x) (/ (log x) (log 2)))
  ;;  (log2 2)
#+end_src

#+name: sqrt_func
#+begin_src scheme 
  (define (square x ) (* x x)) 
#+end_src
** pedagogic scheme factorization
Working scheme implementation of a prime factorizer that returns the greatest prime. This version makes a pretty list of the results for debugging reasons
#+begin_src scheme :results output
  (define (simple-factorize x p)
    (if (>= x (* p p))
        (begin (display x) (display ", ") (display p) (newline)
               (cond
                [(eq? 0 (remainder x p)) (simple-factorize (/ x p) p)]
                [else (simple-factorize x (+ p 1))]))
        (display x)))

  (simple-factorize 25 2)
#+end_src

#+RESULTS:
: Geiser Interpreter produced no output

** working scheme factorization
*** simple-factorization
See [[*pedagogic scheme factorization][pedagogic scheme factorization]] for a printed version of the algorithm. Call:

Added (unnecessary) check for prime using a [[*fermat][fermat test]] which is likely to speed up the function, or making it more accurate for large numbers. Use like this:

~(simple-factorize N p)~ where N is the number to factorize and p is the starting prime (most likely always 2)
#+name: simple_factorize
#+begin_src scheme :results value
  (define (simple-factorize x p)
    (if (>= x (* p p))
        (cond
         [(eq? 0 (remainder x p)) (simple-factorize (/ x p) p)]
         [else (simple-factorize x (+ p 1))]
         )
    x))

  ;; (simple-factorize 25 2)
#+end_src

**** alternate factorization
Use like this: ~(simple-factorize N p)~ where N is the number to factorize and p is the starting prime (most likely always 2). This version checks if number is a prime.
#+name: simple_factorize_fermat
#+begin_src scheme :results value :noweb yes
   <<is_prime>>
   (define (simple-factorize x p)
     (if (fermat-test x)
         x
         (if (>= x (* p p))
             (cond
              [(eq? 0 (remainder x p)) (simple-factorize (/ x p) p)]
              [else (simple-factorize x (+ p 1))]
              )
             x)))

  (simple-factorize 32 2)
#+end_src

Use like this: ~(simple-factorize N p i)~ where
- N is the number to factorize
- p is the starting prime (most likely always 2)
- i is the index of the number of prime factorizations performed (for a prime this will be zero and for a multiple of a prime it will be > 0)
Returns a list of the prime and the multiple 
#+name: simple_factorize_multiple
#+begin_src scheme :results value :noweb yes
   (define (simple-factorize-m x p i)
     (if (>= x (* p p))
             (cond
              [(eq? 0 (remainder x p)) (simple-factorize-m (/ x p) p (+ i 1))]
              [else (simple-factorize-m x (+ p 1) i)]
              )
           (list p i)))

  (simple-factorize-m 21 2 0)
#+end_src

#+RESULTS: simple_factorize_multiple
| 3 | 1 |

*** simple-factorization with a string ratio
*This is the function that is used in the notation script.*

Function to retrieve the extension for the note name as given by the table [[ellis_signs][ellis_signs]] and [[ellis_signs_exponent][ellis_signs_exponent]] based on the largest common prime for the nominator and the denominator in the ratio given by ~R~. The number of commas is also retrieved here.
#+name: ellis_notation
#+begin_src scheme :results output :noweb yes :var ellis=ellis_signs notes=note_names exp=ellis_signs_exponent
  <<simple_factorize>>
  <<simple_factorize_multiple>>
  (define (retrieve-ellis-ext R)
    (let* ((p (apply max
                     (list 
                      (simple-factorize (numerator R) 2)
                      (simple-factorize (denominator R) 2)
                      ))
              )
           )
      p)
    )

  (define (retrieve-ellis-exponent R)
    (let* ((m (car (cdr (simple-factorize-m (numerator R) 2 0)))))
      m)
    )

  (define (ellis-notation R)
    (let* ((a (retrieve-ellis-ext R))
           (b (retrieve-ellis-exponent R)))
      (if (>= a 5)
          (list (car (cddr (assoc a ellis))) (car (cdr (assoc b exp))))
          (list (car (cddr (assoc a ellis))) ""))
      )
    )

  (display (string-join (ellis-notation 33/32) ""))
#+end_src

#+RESULTS: ellis_notation
: ocb

**** alternate factorization functions
Give a ratio as string and returns the largest prime factor of the numerator and denominator by way of [[*working scheme factorization][working scheme factorization]]. In order to calculate the alteration to the notation according to the table [[ellis_signs][ellis_signs]], use the function below: [[retrieve_ellis_extension][retrieve_ellis_extension]].
#+name: full_factorize
#+begin_src scheme :results value :noweb yes :var ratio="81/80"
   <<simple_factorize>>
   (define (full-factorize R)
     (apply max
            (list 
             (simple-factorize (string->number (car (string-split ratio #\/))) 2 )
             (simple-factorize (string->number (car (cdr (string-split ratio #\/)))) 2)
             )
            )
     )
  (full-factorize "5/1")
#+end_src

#+RESULTS: full_factorize
: 5

** generate lilypond code
This is the function to call for generating the notes. Note that the call to note-name currently can only handle a #t value.
- R is the list of ratios to notate
- octred is a boolean for octave reduction
- T is the number of steps to transpose from middle C
#+begin_src scheme :noweb yes :var ellis=ellis_signs notes=note_names exp=ellis_signs_exponent :results output :tangle print.scm :wrap "src lilypond :file micro.png"
  (use-modules (ice-9 format))
  <<ellis_notation>>
  <<note_name>>
  <<octave_to_lily>>
  (define (eh-printer R octred T)
    (begin
      (format #t "~a\n~a\n~a\n~a\n\n" "\\version \"2.24.1\"" "#(ly:set-option 'use-paper-size-for-page #f)" "#(ly:set-option 'tall-page-formats 'png)" "\\include \"ekme-heji.ily\"")
      (format #t "~a = {\n  ~a\n  ~a\n" "music" "\\accidentalStyle \"dodecaphonic\"" "\\fixed c' {")
      (map (lambda (R)
             (format #t "    ~a~a~a\n"
                     (car (note-name R octred T))
                     (string-join (ellis-notation R) "")                    
                     (if (unspecified? (octave-notation (cdr (note-name R octred T))))
                         ""
                         (octave-notation (cdr (note-name R octred T))))))
           R)
      (format #t "  ~a\n~a\n\n" "}" "}")
      (format #t "~a\n  ~a\n    ~a  ~a\n" "\\score {" "\\new Staff {" "\\new Voice {" "\\music")
      (format #t "    ~a\n  ~a\n  ~a\n  ~a\n"  "}" "}" "\\layout{}\n  \\midi{}" "}")
      )
    )

  (eh-printer '(1/1 1/2 1/4) #f 0)
#+end_src

#+RESULTS:
#+begin_src lilypond :file micro.png
ocb(1 . 1)\version "2.24.1"
#(ly:set-option 'use-paper-size-for-page #f)
#(ly:set-option 'tall-page-formats 'png)
\include "ekme-heji.ily"

music = {
  \accidentalStyle "dodecaphonic"
  \fixed c' {
    c
    c,
    c,,
  }
}

\score {
  \new Staff {
    \new Voice {  \music
    }
  }
  \layout{}
  \midi{}
  }
#+end_src


This is the function to call for generating a notes block only to be inserted in a Lilypond file.
- R is the list of ratios to notate
- octred is a boolean for octave reduction
- T is the number of steps to transpose from middle C
#+begin_src scheme :var  ellis=ellis_signs notes=note_names exp=ellis_signs_exponent :results output :wrap src lilypond :tangle print.scm
  (use-modules (ice-9 format))
  <<ellis_notation>>
  <<note_name>>
  <<octave_to_lily>>
  (define (eh-printer fractions octred T)
    (begin
      (format #t "~a = {\n  ~a\n  ~a\n" "music" "\\accidentalStyle \"dodecaphonic\"" "\\fixed c' {")
      (map (lambda (R)
             (format #t "    ~a~a~a\n"
                     (car (note-name R octred T))
                     (string-join (ellis-notation R) "")                    
                     (if (unspecified? (octave-notation (cdr (note-name R octred T))))
                         ""
                         (octave-notation (cdr (note-name R octred T))))))
           fractions)
      (format #t "  ~a\n~a\n\n" "}" "}")
      )
    )

  (eh-printer (list 5/4 3/2 1/1 11/1) #t 0)
#+end_src

#+RESULTS:
#+begin_src lilypond
ocbmusic = {
  \accidentalStyle "dodecaphonic"
  \fixed c' {
    eoaa
    g
    c
    fsoca
  }
}

#+end_src


map/lamba test
#+begin_src scheme :results output
    (define (mytest r)
      (map (lambda (R) (display R)) (list 1/1 2/3 3/4))
      )
    (mytest '(2 3 4))
#+end_src

#+RESULTS:
: 12/33/4


The logic here should be the following:
#+name: ellis_signs
| prime | notation                      | notename |
|-------+-------------------------------+----------|
|     1 | notename + (alteration)       | ""       |
|     2 | notename + (alteration) (f/s) | ""       |
|     3 | notename + (alteration)       | ""       |
|     5 | notename + (alteration) + oaa | "oa"     |
|     7 | notename + (alteration) + oba | "ob"     |
|    11 | notename + (alteration) + oca | "oc"     |
|    13 | notename + (alteration) + oda | "od"     |
|    17 | notename + (alteration) + oea | "ae"     |
|-------+-------------------------------+----------|

The logic here should be the following:
#+name: ellis_signs_exponent
| exponent | notename |
|----------+----------|
|        0 | "a"      |
|        1 | "b"      |
|        2 | "c"      |
|        3 | "d"      |
|        4 | "e"      |
|----------+----------|

** prime numbers
This works fine.
*** fermat
Perform a Fermat test if the given number is a prime number. [[https://aliquote.org/post/prime-factorization/][Extracted from here]].
#+name: is_prime
#+begin_src scheme :results value :noweb yes
    (define (square x) (* x x)) 

    (define (expmod base exp m) 
      (cond ((= exp 0) 1)
            ((even? exp) 
             (remainder (square (expmod base (/ exp 2) m)) 
                        m)) 
            (else 
             (remainder (* base (expmod base (- exp 1) m)) 
                        m))))         

    (define (full-fermat-prime? n) 
      (define (iter a n) 
        (if (= a n) true 
            (if (= (expmod a n n) a) (iter (+ a 1) n) false))) 
      (iter 1 n)) 

  (define (fermat-test n)
    (define (test a)
      (= (expmod a n n) a))
    (define (iter a)
      (if (< a n)
          (if (test a)
              (iter (+ a 1))
              #f)
          #t))
    (iter 1))

  (fermat-test 5)
#+end_src

#+RESULTS: is_prime
: #t

* synthesis
Load ~midi_ctrl~ and play with the preset in the table, or create a new table.

Free function
#+name: free_all
#+begin_src sclang :results none
  MIDIIn.removeFuncFrom(\noteOn, ~noteOn);
  MIDIIn.removeFuncFrom(\noteOff, ~noteOff);
  MIDIIn.removeFuncFrom(\control, ~control);
#+end_src

#+name: midi_ctrl
#+begin_src sclang :results none :noweb yes  :var tab=tab_notes
  (
  <<play_function>>
  <<set_function>>

  MIDIClient.init;
  MIDIIn.connectAll;
  MIDIIn.connect;    // init for one port midi interface
  ~noteOff = { arg src, chan, num, vel;    [chan,num,vel / 127].postln; };

  ~noteOn = { arg src, chan, num, vel;    [chan,num,vel / 127].postln; };

  ~control = { arg src, chan, num, val;
          "here".postln;
          [chan,num,val].postln;
          if(chan == 0 && num >= 36 && num <= 51,
                  {
                          val.postln;
                          num.postln;			
                          if(val > 0,
                                  {~player.value(num)},         // here is where the actions is}
                                  {~setter.value(num, \gate, 0)}
                          );
                  });
  };
  MIDIIn.addFuncTo(\noteOn, ~noteOn);
  MIDIIn.addFuncTo(\noteOff, ~noteOff);
  MIDIIn.addFuncTo(\control, ~control);
  );
#+end_src

#+name: play_function
#+begin_src sclang :results none :noweb yes :var tab=tab_notes
  <<harmonic_synthdef>>
  <<lookup>>
  ~player = { arg val=0;
          var index = val - 36, fund  = 60, ratio = 1/1, freq = ~main_root;
          ratio = ~lookup.value(index)[3];
          fund = fund + ~lookup.value(index)[1];
          freq = ratio * (fund.midicps);
          "lookup gives: ".post; ~lookup.value(index).postln;
          "index is: ".post; index.postln;
          "ratio is: ".post; ratio.postln;
          "freq is: ".post; freq.postln;
          ~synths.put(index, Synth.new(\osc, [\root, fund, \freq, freq, \amplitude, 0.3 , \gate, 1]));
  };

#+end_src

#+name: set_function
#+begin_src sclang :results none
  ~setter = { arg index, param, val=0;          
          var synth, i;
          i = index - 36;
          synth = ~synths.at(i);
          synth.set(param, 0);
  };
#+end_src

#+name: harmonic_synthdef
#+begin_src sclang :results none
  SynthDef(\osc, { arg root=440, freq=440, amplitude=0.2, gate=1, out=0;
          var amp, sig;
          amp = amplitude;
          sig = SinOsc.ar(freq, 0, amp);
          Out.ar(out, sig * EnvGen.kr(Env.adsr, gate, doneAction: Done.freeSelf));
  }).add;
#+end_src

Function returns an array with the key, octave, index and ratio (as a decimal)
#+name: lookup
#+begin_src sclang :results none :var tab=tab_notes
  ~lookup = { arg index=0;
          var i = index + 2,
          key = tab[i][1],
          octave = tab[i][2],
          harmi = tab[i][3],
          ratio = tab[i][4] / tab[i][5],
          result;
          result = [key, octave, harmi, ratio];
  };
#+end_src

First column is an index, second is the root, third is the index in the harmonic series.
#+name: tab_notes
| index | BU16 | root | harmonic | 5- limit |    |
|       |      |      |   series |        N |  D |
|-------+------+------+----------+----------+----|
|     0 |   36 |    0 |        1 |       64 | 63 |
|     1 |   37 |    0 |        2 |        1 |  1 |
|     2 |   38 |    0 |        3 |        5 |  4 |
|     3 |   39 |    0 |        4 |        6 |  5 |
|     4 |   40 |    0 |        5 |        8 |  5 |
|     5 |   41 |    0 |        6 |        5 |  3 |
|     6 |   42 |    0 |        7 |        4 |  3 |
|     7 |   43 |    0 |        8 |          |    |
|-------+------+------+----------+----------+----|
|     8 |   44 |    7 |        9 |        1 |  1 |
|     9 |   45 |    7 |       10 |        3 |  2 |
|    10 |   46 |    7 |       11 |        5 |  4 |
|    11 |   47 |    7 |       12 |        6 |  5 |
|    12 |   48 |    7 |       13 |        8 |  5 |
|    13 |   49 |    7 |       14 |        5 |  3 |
|    14 |   50 |    7 |       15 |        4 |  3 |
|    15 |   51 |    7 |       16 |          |    |

#+name: tab_notes_five
| index | BU16 | root | harmonic | 5- limit |   |
|       |      |      |   series |        N | D |
|-------+------+------+----------+----------+---|
|     0 |   36 |    0 |        1 |        1 | 1 |
|     1 |   37 |    0 |        2 |        3 | 2 |
|     2 |   38 |    0 |        3 |        5 | 4 |
|     3 |   39 |    0 |        4 |        6 | 5 |
|     4 |   40 |    0 |        5 |        8 | 5 |
|     5 |   41 |    0 |        6 |        5 | 3 |
|     6 |   42 |    0 |        7 |        4 | 3 |
|     7 |   43 |    0 |        8 |          |   |
|-------+------+------+----------+----------+---|
|     8 |   44 |    7 |        9 |        1 | 1 |
|     9 |   45 |    7 |       10 |        3 | 2 |
|    10 |   46 |    7 |       11 |        5 | 4 |
|    11 |   47 |    7 |       12 |        6 | 5 |
|    12 |   48 |    7 |       13 |        8 | 5 |
|    13 |   49 |    7 |       14 |        5 | 3 |
|    14 |   50 |    7 |       15 |        4 | 3 |
|    15 |   51 |    7 |       16 |          |   |


#+Begin_src sclang :results none
  (
  MIDIClient.init;
  MIDIIn.connectAll;
  MIDIIn.connect;    // init for one port midi interface
  ~noteOff = { arg src, chan, num, vel;    [chan,num,vel / 127].postln; };

  ~noteOn = { arg src, chan, num, vel;    [chan,num,vel / 127].postln; };

  ~control = { arg src, chan, num, val;
          var root_l=60, amp_l=0.2;
          [chan,num,val].postln;
          x = switch(num)
          {44}

          { "hello".postln; }

          {99} {
                  if (val == 127,  
                          {a = Synth.new(\osc, [\root, root_l.midicps, \pos, 1, \amplitude, amp_l, \gate, 1 ]);},
                          {a.set(\gate, 0); a.free;}); 
          }

          {45} {
                  if (val == 127,  
                          {b = Synth.new(\osc, [\root, (root_l + 7).midicps, \pos, 1, \amplitude, amp_l,  \gate, 1]);},
                          {b.set(\gate, 0); b.free;}); 
          }
          {46} {
                  if (val == 127,  
                          {c = Synth.new(\osc, [\root, (root_l + 2).midicps, \pos, 1, \amplitude, amp_l, \gate, 1]);},
                          {c.set(\gate, 0); c.free;}); 
          }
          {47} {
                  if (val == 127,  
                          {d = Synth.new(\osc, [\root, (root_l + 9).midicps, \pos, 1, \amplitude, amp_l, \gate, 1]);},
                          {d.set(\gate, 0); d.free;}); 
          }
          {40} {
                  if (val == 127,  
                          {e = Synth.new(\osc, [\root, root_l.midicps, \pos, 2, \amplitude, amp_l, \gate, 1 ]);},
                          {e.set(\gate, 0); e.free;}); 
          }
          {41} {
                  if (val == 127,  
                          {f = Synth.new(\osc, [\root, (root_l + 7).midicps, \pos, 2, \amplitude, amp_l,  \gate, 1]);},
                          {f.set(\gate, 0); f.free;}); 
          }
          {42} {
                  if (val == 127,  
                          {g = Synth.new(\osc, [\root, (root_l + 2).midicps, \pos, 2, \amplitude, amp_l, \gate, 1]);},
                          {g.set(\gate, 0); g.free;}); 
          }
          {43} {
                  if (val == 127,  
                          {a = Synth.new(\osc, [\root, (root_l + 9).midicps, \pos, 2, \amplitude, amp_l, \gate, 1]);},
                          {a.set(\gate, 0); a.free;}); 
          }
          {20} {
                  if (val == 127,  
                          {h = Synth.new(\osc, [\root, root_l.midicps, \pos, 3, \amplitude, amp_l, \gate, 1 ]);},
                          {h.set(\gate, 0); h.free;}); 
          }
          {21} {
                  if (val == 127,  
                          {i = Synth.new(\osc, [\root, (root_l + 7).midicps, \pos, 3, \amplitude, amp_l,  \gate, 1]);},
                          {i.set(\gate, 0); i.free;}); 
          }
          {22} {
                  if (val == 127,  
                          {j = Synth.new(\osc, [\root, (root_l + 2).midicps, \pos, 3, \amplitude, amp_l, \gate, 1]);},
                          {j.set(\gate, 0); j.free;}); 
          }
          {23} {
                  if (val == 127,  
                          {k = Synth.new(\osc, [\root, (root_l + 9).midicps, \pos, 3, \amplitude, amp_l, \gate, 1]);},
                          {k.set(\gate, 0); k.free;}); 
          }
          {16} {
                  if (val == 127,  
                          {l = Synth.new(\osc, [\root, root_l.midicps, \pos, 4, \amplitude, amp_l, \gate, 1 ]);},
                          {l.set(\gate, 0); l.free;}); 
          }
          {17} {
                  if (val == 127,  
                          {m = Synth.new(\osc, [\root, (root_l + 7).midicps, \pos, 4, \amplitude, amp_l,  \gate, 1]);},
                          {m.set(\gate, 0); m.free;}); 
          }
          {18} {
                  if (val == 127,  
                          {n = Synth.new(\osc, [\root, (root_l + 2).midicps, \pos, 4, \amplitude, amp_l, \gate, 1]);},
                          {n.set(\gate, 0); n.free;}); 
          }
          {19} {
                  if (val == 127,  
                          {o = Synth.new(\osc, [\root, (root_l + 9).midicps, \pos, 4, \amplitude, amp_l, \gate, 1]);},
                          {o.set(\gate, 0); o.free;}); 
          }
          {60} {
                  a.set(\root, (((val / 12) - 6) + root_l).midicps);
          }
          {61} {
                  b.set(\root, (((val / 12) - 6) + root_l).midicps);
          }
          {62} {
                  c.set(\root, (((val / 12) - 6) + root_l).midicps);
          }
          {63} {
                  d.set(\root, (((val / 12) - 6) + root_l).midicps);
          }
          {56} {
                  e.set(\root, (((val / 12) - 6) + root_l).midicps);
          }
          {57} {
                  f.set(\root, (((val / 12) - 6) + root_l).midicps);
          }
          {58} {
                  g.set(\root, (((val / 12) - 6) + root_l).midicps);
          }
          {59} {
                  h.set(\root, (((val / 12) - 6) + root_l).midicps);
          }
          {52} {
                  i.set(\root, (((val / 12) - 6) + root_l).midicps);
          }
          {53} {
                  j.set(\root, (((val / 12) - 6) + root_l).midicps);
          }
          {54} {
                  k.set(\root, (((val / 12) - 6) + root_l).midicps);
          }
          {55} {
                  l.set(\root, (((val / 12) - 6) + root_l).midicps);
          }
          {48} {
                  m.set(\root, (((val / 12) - 6) + root_l).midicps);
          }
          {49} {
                  n.set(\root, (((val / 12) - 6) + root_l).midicps);
          }
          {50} {
                  o.set(\root, (((val / 12) - 6) + root_l).midicps);
          }
          {51} {
                  p.set(\root, (((val / 12) - 6) + root_l).midicps);
          };
  };

  MIDIIn.addFuncTo(\noteOn, ~noteOn);
  MIDIIn.addFuncTo(\noteOff, ~noteOff);
  MIDIIn.addFuncTo(\control, ~control);
  )
#+end_src

* lily version and paper
#+name: version-and-paper
#+begin_src lilypond :exports none
  \version "2.24.1"
  #(ly:set-option 'use-paper-size-for-page #f)
  #(ly:set-option 'tall-page-formats 'png)
  \paper{
    indent=0\mm
    tagline=""
    line-width=170\mm
    oddFooterMarkup=##f
    oddHeaderMarkup=##f
    bookTitleMarkup=##f
    scoreTitleMarkup=##f
  }
  #+end_src
